This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-02T17:54:28.342Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Dockerfile
go.mod
go.sum
main.go

================================================================
Repository Files
================================================================

================
File: Dockerfile
================
FROM golang:1.23-alpine

WORKDIR /app

COPY go.mod go.sum ./

RUN go mod download && go mod verify

COPY . .

RUN go build -o main .

EXPOSE 8080

CMD ["./main"]

================
File: go.mod
================
module planning

go 1.23.3

require (
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
)

================
File: go.sum
================
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=

================
File: main.go
================
package main

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
)

type Room struct {
	ID            string
	Tickets       []Ticket
	Users         map[string]*User
	GameMaster    string
	CurrentTicket int
	VotesRevealed bool
	Mu            sync.RWMutex
}

type Ticket struct {
	ID    string
	Votes map[string]int
}

type User struct {
	Name string
	Conn *websocket.Conn
}

type Message struct {
	Type    string      `json:"type"`
	Payload interface{} `json:"payload"`
	Error   string      `json:"error,omitempty"`
}

type LogEntry struct {
	Time     time.Time `json:"time"`
	Event    string    `json:"event"`
	RoomID   string    `json:"roomId"`
	User     string    `json:"user,omitempty"`
	TicketID string    `json:"ticketId,omitempty"`
	Vote     int       `json:"vote,omitempty"`
	Error    string    `json:"error,omitempty"`
}

var (
	rooms    = make(map[string]*Room)
	roomsMu  sync.RWMutex
	upgrader = websocket.Upgrader{
		CheckOrigin: func(r *http.Request) bool { return true },
	}
	ErrRoomNotFound   = errors.New("room not found")
	ErrUserExists     = errors.New("user already exists in room")
	ErrInvalidPayload = errors.New("invalid message payload")
)

func logEvent(entry LogEntry) {
	entry.Time = time.Now()
	jsonLog, _ := json.Marshal(entry)
	log.Printf("%s", jsonLog)
}

func createRoom(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var data struct {
		TicketIDs []string `json:"ticketIds"`
	}
	if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if len(data.TicketIDs) == 0 {
		http.Error(w, "No tickets provided", http.StatusBadRequest)
		return
	}

	roomID := uuid.New().String()
	tickets := make([]Ticket, len(data.TicketIDs))
	for i, id := range data.TicketIDs {
		tickets[i] = Ticket{
			ID:    id,
			Votes: make(map[string]int),
		}
	}

	room := &Room{
		ID:            roomID,
		Tickets:       tickets,
		Users:         make(map[string]*User),
		CurrentTicket: 0,
		VotesRevealed: false,
	}

	roomsMu.Lock()
	rooms[roomID] = room
	roomsMu.Unlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"roomId": roomID})
}

func handleWebSocket(w http.ResponseWriter, r *http.Request) {
	roomID := r.URL.Query().Get("roomId")
	userName := r.URL.Query().Get("name")
	isGameMaster := r.URL.Query().Get("gamemaster") == "true"

	if roomID == "" || userName == "" {
		http.Error(w, "Missing roomId or name", http.StatusBadRequest)
		return
	}

	roomsMu.RLock()
	room, exists := rooms[roomID]
	roomsMu.RUnlock()

	if !exists {
		http.Error(w, "Room not found", http.StatusNotFound)
		return
	}

	room.Mu.Lock()
	if _, exists := room.Users[userName]; exists {
		room.Mu.Unlock()
		http.Error(w, "Username already taken", http.StatusConflict)
		return
	}
	room.Mu.Unlock()

	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("WebSocket upgrade error: %v", err)
		return
	}

	user := &User{
		Name: userName,
		Conn: conn,
	}

	room.Mu.Lock()
	if isGameMaster && room.GameMaster == "" {
		room.GameMaster = userName
	}
	room.Users[userName] = user
	room.Mu.Unlock()

	defer func() {
		conn.Close()
		room.Mu.Lock()
		delete(room.Users, userName)
		if userName == room.GameMaster {
			room.GameMaster = ""
		}
		room.Mu.Unlock()
		broadcastRoomState(room)
	}()

	broadcastRoomState(room)

	for {
		var msg Message
		if err := conn.ReadJSON(&msg); err != nil {
			break
		}

		switch msg.Type {
		case "vote":
			handleVote(room, userName, msg)
		case "reveal":
			handleReveal(room, userName)
		case "next":
			handleNext(room, userName)
		}
	}
}

func handleVote(room *Room, userName string, msg Message) {
	if room.GameMaster == userName {
		return
	}

	payload, ok := msg.Payload.(map[string]interface{})
	if !ok {
		return
	}

	ticketID, ok1 := payload["ticketId"].(string)
	voteFloat, ok2 := payload["vote"].(float64)
	if !ok1 || !ok2 {
		return
	}

	vote := int(voteFloat)

	room.Mu.Lock()
	if ticketID == room.Tickets[room.CurrentTicket].ID {
		for i, ticket := range room.Tickets {
			if ticket.ID == ticketID {
				room.Tickets[i].Votes[userName] = vote
				break
			}
		}
	}
	room.Mu.Unlock()

	broadcastRoomState(room)
}

func handleReveal(room *Room, userName string) {
	if room.GameMaster != userName {
		return
	}

	room.Mu.Lock()
	room.VotesRevealed = true
	room.Mu.Unlock()

	broadcastRoomState(room)
}

func handleNext(room *Room, userName string) {
	if room.GameMaster != userName {
		return
	}

	room.Mu.Lock()
	if room.CurrentTicket < len(room.Tickets)-1 {
		room.CurrentTicket++
		room.VotesRevealed = false
	}
	room.Mu.Unlock()

	broadcastRoomState(room)
}

func broadcastRoomState(room *Room) {
	room.Mu.RLock()
	defer room.Mu.RUnlock()

	msg := Message{
		Type:    "roomState",
		Payload: room,
	}

	for _, user := range room.Users {
		user.Conn.WriteJSON(msg)
	}
}

func main() {
	http.HandleFunc("/create-room", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

		if r.Method == "OPTIONS" {
			return
		}
		createRoom(w, r)
	})
	http.HandleFunc("/ws", handleWebSocket)

	log.Printf("Server starting on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
